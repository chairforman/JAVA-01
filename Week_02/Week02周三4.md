# 串行GC： #
由于串行的原因，缺点很明显，不能充分利用多核CPU的优势，一般不会使用到生产环境上。

- GCLogAnalysis演示情况：
<br/>情况1，生成对象8000到10000；
<br/>情况2，生成对象8000到10000，去掉的Xms参数似乎影响不大；
<br/>情况3，生成对象12000到13000，Minor GC极少发生，Full GC没有发生，节省了垃圾回收时间；
<br/>情况4，生成对象10000，吞吐量退化了，和512m的时候相差不大。
<br/>年轻代使用标记-复制算法，老年代使用标记-清除-整理算法。

# 并行GC： #
是Java8的默认垃圾收集器。弥补了串行的缺点，充分利用多核CPU优势，回收效率高，更容易达到高吞吐量，但因为触发STW事件，不适用于对延迟非常敏感的系统。


- GCLogAnalysis演示情况：
<br/>情况1，生成对象7000到9000，发生GC的次数比串行GC要多，吞吐量波动较大；
<br/>情况2，生成对象5000，跟串行GC相比，退化很明显；
<br/>情况3，生成对象15000到16000，大内存下，吞吐量优势明显；
<br/>情况4，生成对象5000，同样，不设置起始Xms参数，退化很明显。
<br/>年轻代使用标记-复制算法，老年代使用标记-清除-整理算法。

# CMS GC： #
为了解决并行GC的延迟，对老年代垃圾回收使用并发处理，并发会与应用线程争抢CPU时间，所以吞吐量会比并行GC要低。默认使用的并发线程是CPU内核的1/4，非物理机部署应用的情况下，最好指定并发线程。


- GCLogAnalysis演示情况：
<br/>情况1，生成对象9000到10000，小内存下，吞吐量反而比并行GC高；
<br/>情况2，生成对象9000到10000，不设置起始Xms参数，影响不大；
<br/>情况3，生成对象14000，大内存下，吞吐量虽然上来了，但确实比并行GC少；
<br/>情况4，生成对象10000到11000，吞吐量还是比设置了起始Xms参数的要少。
<br/>相对于之前的GC，CMS每次发生GC的占用时间都控制得很平缓。
<br/>年轻代使用标记-复制算法，老年代使用标记-清除算法。

# G1 GC： #
堆内存不划分连续的年轻代和老年代空间，划分成多个小堆区域，每个区域都有可能是Eden区，S区或Old区，通过估算每个区域的对象总数，对垃圾最多的区域优先回收。


- GCLogAnalysis演示情况：
<br/>情况1，生成对象4000到8000，可见，小内存下，吞吐量不及前三种GC；
<br/>情况2，生成对象5000到8000，不设置起始Xms参数，影响不大；
<br/>情况3，生成对象13000到15000，大内存下，G1几乎做到并行GC一样的吞吐量；
<br/>情况4，生成对象9000到11000，吞吐量还是比设置了起始Xms参数的要少。